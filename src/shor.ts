import Complex from './complex';
import QuReg from './quReg';
import {
  denominator,
  dfp,
  gcd,
  getQ, getX,
  max,
  modexp,
  regSize, testEven,
  testPrime,
  testPrimePower,
} from './util';

export class Shor {
  shorsAlgorithm(n: number) {
    console.group('Шаг 1: Определить, является ли число (n) простым, четным или целой степенью простого числа');
    // Проверка на четность
    if (testEven(n)) {
      throw new Error('Число должно быть нечетным');
    }

    // Проверка на простоту.
    if (testPrime(n)) {
      throw new Error('Число должно быть простым');
    }

    // Проверка на принодлежности числа к степень простого числа
    if (testPrimePower(n)) {
      throw new Error('Число не должно быть степенью простого числа');
    }

    console.groupEnd();

    console.group('Шаг 2: Получить наименьшее целое число q, которое будет являться степенью 2, такое, что n^2 <= q < 2n^2');

    const q = getQ(n);

    console.log(`Наше число q = ${q}`);
    console.groupEnd();

    console.group('Шаг 3: Получить случайное целое число x, которое взаимно просто с n');

    let x = getX(n);

    console.log(`Найденое значение x = ${x}`);
    console.groupEnd();

    console.group('Шаг 4: Создать квантовый регистр и разделите его на две части: reg1 и reg2. ' +
      'Таким образом, состояние нашего квантового компьютера может быть задано как: |reg1, reg2⟩ ' +
      'Регистр 1 должен иметь достаточно кубитов для представления целых чисел размером до q - 1. ' +
      'Регистр 2 должен иметь достаточно кубитов для представления целых чисел размером до n - 1. ');

    // Мы должны создать квантовый регистр, достаточно большой, чтобы вместить суперпозицию (после преобразоваия Уолша-Адамара) всех целых чисел от 0 до q - 1
    const reg1 = new QuReg(regSize(q) - 1);

    console.log(`Размер регистра 1 = ${regSize(q) - 1}`);


    // Этот регистр должен быть достаточно большим, чтобы вместить суперпозицию чисел от 0 до n - 1
    const reg2 = new QuReg(regSize(n));
    console.log(`Размер регистра 2 = ${regSize(n)}`);

    console.groupEnd();

    // TODO: Проверить комментарий
    // Этот массив запомнает, какие значения q получены для x^q mod n.
    // Необходимо сохранить эти значения для использования при сворачивании
    // регистрира один после измерения регистра два. В реальном квантовом
    // компьютере эти регистры будут запутаны, и, следовательно, это лишная
    // операция вообще не понадобится. Законы квантовые
    // механика говорят, что первый регистр тоже рухнет, и
    // в состояние, соответствующее измеренному значению второго резистора.

    //This array will remember what values of q produced for x^q mod n.
    //It is necessary to retain these values for use when we collapse
    //register one after measuring register two.  In a real quantum
    //computer these registers would be entangled, and thus this extra
    //bookkeeping would not be needed at all.  The laws of quantum
    //mechanics dictate that register one would collapse as well, and
    //into a state consistent with the measured value in resister two.
    const modex = [];


    // TODO: Проверить комментарий
    // Этот массив содержит амплитуды вероятности свернутого состояния
    // первого регистра, после измерения второго регистра он используется
    // чтобы привести первый регистр в состояние, соответствующее измеренному в
    // регистрире два.

    //This array holds the probability amplitudes of the collapsed state
    //of register one, after register two has been measured it is used
    //to put register one in a state consistent with that measured in
    //register two.
    const collapse = Array.from({ length: q }, () => new Complex());

    // Это временное значение.
    const tmp = new Complex();

    // Это новый массив амплитуд вероятности для нашего второго
    // квантового регистра, заполняемый результатами x^a mod n.
    const mdx = Array.from({ length: Math.pow(2, regSize(n)) }, () => new Complex());

    // Это временное значение.
    let tmpval = 0;

    // Это временное значение.
    let value = 0;


    // lambda — некоторая кратная лямбда числа q/r, где q это полученное значение,
    // r — это период, который мы пытаемся найти для факторизации n.
    // m - значение, которое мы измеряем из первого регистра после преобразования Фурье.
    let lambda;
    let m;

    //  p используется для хранения числителя дроби p/den, где
    //  p/den — лучшее приближение к lambda с den <= q.
    let p;

    // den используется для хранения знаменателя дроби p/den, где
    // p/den — лучшее приближение к значению lambda с den <= q.
    let den;


    // Числа e, a и b используются в конце программы, когда
    // мы пытаемся вычислить множители n
    // factor — это множители, который мы находим.
    let e, a, b, factor;


    // Алгоритм Шора может давать сбой, и в этом случае мы повроряем вычисления заново
    // Переменная done устанавливается в false, когда алгоритм не завершился
    // tries - максимальное кол-во попыток
    let done = false;
    let tries = 0;

    while (!done) {
      if (tries >= 10) {
        console.error('Прошло максимальное кол-во попыпок');
        return;
      }

      console.group(`Шаг 5: Загрузить в регистр 1 равновзвешенную суперпозицию всех целых чисел от 0 до q - 1. Загрузить в регистр 2 все нули.
                           Попытка произвести алгоритм: ${tries + 1}`);
      // Преоразование Уолша-Адамара H = 1/2^-0.5 [1 1
      //                                           1 -1]


      // Заполняем первый регистр равновзвешенной суперпозицией целых чисел 0 до q - 1.
      reg1.setAverage(q - 1);
      reg2.setToStart(regSize(n));
      console.log('Регистр 1 после заполнения:', reg1.state.map((el) => [el.getReal(), el.getImaginary()]));
      console.log('Регистр 2 после заполнения:', reg2.state.map((el) => [el.getReal(), el.getImaginary()]));
      console.groupEnd();

      console.group(`Шаг 6: Теперь применяем преобразование x^a mod(n) для каждого числа, хранящегося в регистре 1, и сохранием результат в регистре 2,
                           где a - значения с первого регистра. Попытка произвести алгоритм: ${tries + 1}`);

      //  Теперь мы выполняем модульное возведение в степень элементов из reg1.
      //  То есть выполняем x^a mod n.
      //
      //  Используя квантовый параллелизм, квантовый компьютер мог бы сделать это за один
      //  шаг, тогда как мы должны вычислить его один раз для каждого возможного
      //  значения в первом регистре. Сохраняем результат в регистр reg2,
      //  который связан с первым регистром.
      //
      //  Это означает, что когда какой-то регистр измеряется и сворачивается в базу
      //  состояний, другой регистр должен схлопнуться в суперпозицию
      //  состояний, соответствующие измеренному значению в другом.
      //
      //  Размер результата модульного возведения в степень будет не более n, поэтому
      //  количество битов, которое нам понадобится, меньше или равно log2 от n.
      //
      //  На этом этапе мы также сохраняем в массив того, что каждое состояние
      //  создало при модульном возведении в степень, потому что
      //  эти регистры на самом деле будут запутаны в реальном квантовом
      //  компьютере, эта информация понадобится при сворачивании первого
      //  регистра позже.

      // Переменная-счетчик. Используется для увеличения нашей амплитуды вероятности.
      tmp.set(1, 0);

      // Этот цикл for охватывает q и помещает значение x^a mod(n) в
      // modex[i]. Это также увеличивает амплитуду вероятности значения
      // mdx[x^a mod n] в нашем массиве комплексных вероятностей.
      for (let i = 0; i < q; i++) {
        tmpval = modexp(x, i, n);
        modex[i] = tmpval;
        mdx[tmpval].assignment(mdx[tmpval].add(tmp));
      }

      console.log(modex.map((el) => el));
      // Устанавливаем состояние второго регистра значениями x^a mod n.
      reg2.setState(mdx);
      console.log('Регистр 2 после заполнения значениями x^a mod n:', reg2.state.map((el) => [el.getReal(), el.getImaginary()]));

      // Нормализация второго регистра, так чтобы вероятность измерения
      // состояния определялась суммой квадратов его вероятностей амплитуды
      reg2.norm();
      console.log('Регистр 2 после нормализации:', reg2.state.map((el) => [el.getReal(), el.getImaginary()]));
      console.groupEnd();

      console.group(`Шаг 7: Измерить второй регистр. Мы будем наблюдать некоторое значение k. Побочным эффектом этого является свертывание первого регистра в равную суперпозицию 
                          каждого значения a между 0 и q - 1 таких как x^a mod(n) = k. Попытка произвести алгоритм: ${tries + 1}`);

      //Вычеслияем reg2.
      value = reg2.decMeasure();

      console.log('k =', value);

      // Теперь мы должны использовать информацию из массива modex, который содержит коллапсирующие состояния
      // первого регистра в состояние, которое соответствует значению вычесленном во втором регистре
      for (let i = 0; i < q; i++) {
        if (modex[i] === value) {
          collapse[i].set(1, 0);
        } else {
          collapse[i].set(0, 0);
        }
      }


      // Теперь мы устанавливаем состояние первого регистра так, чтобы оно соответствовало тому, что
      // мы измеряли во втором состоянии и нормализуем вероятность амплитуды.
      reg1.setState(collapse);
      reg1.norm();
      console.log('Регистр 1:', reg1.state.map((el) => [el.getReal(), el.getImaginary()]));
      console.groupEnd();

      console.group(`Шаг 8: Теперь вычислим дискретное преобразование Фурье для первого регистра. Попытка произвести алгоритм: ${tries + 1}`);

      // Преобразование Фурье.
      dfp(reg1, q);
      console.log('Регистр 1 после преобразования Фурье:', reg1.state.map((el) => [el.getReal(), el.getImaginary()]));
      console.groupEnd();

      console.group(`Шаг 9: Измерьть состояние первого регистра, назовем это значение m - это целое число с очень высокой вероятностью будет кратным q/r , где r — желаемый период.
                          Попытка произвести алгоритм: ${tries + 1}`);

      // Далее мы измеряем первый регистр, m будет кратно lambda/r, где
      // lambda — целое число, а r — желаемый период.
      m = reg1.decMeasure();
      console.log(`Измеренное состояние первого регистра: m = ${m}`);
      console.groupEnd();

      // Если с этого момента все пройдет гладко, то мы завершим алгоритм
      done = true;


      // Если m === 0, мы не получили новой информации о
      // периоде, мы должны попробовать еще раз.
      if (m === 0) {
        console.warn(`m === 0, Попытка ${tries + 1} провалилась`);
        done = false;
      }

      // decMeasure вернет -1 в качестве кода ошибки, поскольку
      // из-за ошибок округления иногда не удается измерить состояние.
      if (m === -1) {
        console.warn('m === 1, Попытка ${tries + 1} провалилась');
        done = false;
      }

      // Если все хорошо, то пробуем определить период нашей функции и получить коэффициенты n.
      if (done) {

        //Сейчас c =~ lambda / r для некоторой целочисленной lambda.
        // TODO: удалить этот коммент
        // Заимствовано у модификации Бернарда Опнера.
        lambda = m / q;

        console.group(`Шаг 10: Взять значение m и выполнить постобработку, которая вычислит r на основе значений m и q.
        В частности:
        1) m имеет высокую вероятность быть равное lambda * ( q/r ), где – целое lambda целое
        2) Если мы получим деление m/q с плавающей запятой, то вычислим наилучшее рациональное приближение к m/q, знаменатель которого меньше или равен q
        3) Мы принимаем этот знаменатель в качестве кандидата на r
        4) Если наш кандидат r нечетный, мы удваиваем его, если это приводит к значению меньше q.
        Попытка произвести алгоритм: ${tries + 1}`);


        // TODO: проверить коммент
        // Вычисляем знаменатель наилучшего рационального приближения
        // к lambda с den < q. Поскольку lambda — это lambda/r для некоторого целого числа
        // lambda, это даст нам предположение о, нашем периоде.

        //Calculate the denominator of the best rational approximation
        //to c with den < q.  Since c is lambda / r for some integer
        //lambda, this will provide us with our guess for r, our period.
        den = denominator(lambda, q);

        //Вычисляем числитель из знаменателя.
        p = Math.floor(den * lambda + 0.5);

        console.log(`Полученное m = ${m}, рациональное приближение для m/q = ${lambda} это ${p}/${den}`)


        // Знаменатель – это наш период. Если он нечетный, то это бесполезный
        // результат алгоритма Шора. Если знаменатель
        // умноженный два все равно меньше q, мы можем его использовать.
        if (den % 2 === 1 && 2 * den < q) {
          console.warn('Наш период нечетный. Умножаем его на 2');
          p = 2 * p;
          den = 2 * den;
        }

        // TODO: перефразировать
        // Инициализация помогающий переменых
        e = a = b = factor = 0;

        // Ошибка, если знаменатель нечетный.
        if (den % 2 === 1) {
          console.error(`Найденый период нечетный. Попытка ${tries + 1} провалилась`);
          done = false;
          console.groupEnd();
        } else {
          console.groupEnd();

          console.group(`Шаг 11: Как только мы достигли r, коэффициент n можно определить, взяв НОД(x^r/2 + 1, n) и НОД(x^r/2 - 1, n). Если мы нашли множители n, то останавливаем алгорит, если нет, то переходим к шагу 4.
                              Попытка произвести алгоритм: ${tries + 1}`);

          console.log(`Кандидат в период: ${den}`);

          // Рассчитываем кандидатов на возможные общие делители с n.
          e = modexp(x, den / 2, n);
          a = (e + 1) % n;
          b = (e + n - 1) % n;

          console.log(
            `${x} ^ ${den / 2} + 1 mod ${n} = ${a}, ${x} ^ ${den / 2} - 1 mod ${n} = ${b}`,
          );

          if (a === 0 || b === 0) {
            done = false;
            console.warn('Один из ответов x^r/2 +- 1 mod(n) = 0');
          } else {
            factor = max(gcd(n, a), gcd(n, b));
          }
        }
      }

      // //НОД вернет -1, если попытается вычислить НОД из двух
      // //чисел, где в какой-то момент он пытается принять модуль
      // //число и 0.
      //
      // //GCD will return a -1 if it tried to calculate the GCD of two
      // //numbers where at some point it tries to take the modulus of a
      // //number and 0.
      // if (factor === -1) {
      //   console.log('tError, tried to calculate n mod 0 for some n.  Trying again.');
      //   done = false;
      // }

      if ((factor === n || factor === 1) && done) {
        console.log(`Найдены тривиальные множетели 1 и ${n}. Попытка ${tries + 1} не удалась`);
        done = false;
      }

      // Если все прошло гладко, то мы завершаем алгоритм.
      // В противном случае начинаем сначала.

      if (factor !== 0 && done) {
        console.log(`${n} = ${factor} * ${n / factor}`);
      } else if (done) {
        console.log(`Найденый множетель 0. Попытка ${tries + 1} не удалась`);
        done = false;
      }

      console.groupEnd();
      tries++;
    }
  }
}
